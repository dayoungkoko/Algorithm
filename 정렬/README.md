# 1. 선택 정렬

- 정렬되지 않은 데이터 중 가장 작은 데이터를 선택하여 맨 앞으로 보내면서 정렬한다.
- 시간 복잡도 : $O(N^2)$


# 2. 삽입 정렬

- 특정 데이터를 적절한 위치에 삽입한다
    - 특정 데이터 기준 앞쪽은 이미 정렬되어 있다고 가정한다
    - 특정 데이터와 앞의 데이터를 하나씩 비교해나간다
    - 특정 데이터가 삽입될 위치를 찾으면 그곳에 삽입한다
- 시간 복잡도 : $O(N^2)$다
    - 단, 이미 거의 정렬된 리스트의 경우, 삽입 정렬이 매우 빠르게 동작한다.
    
# 3. 퀵 정렬

- 가장 많이 사용되는 알고리즘
- 기준 데이터(피벗)을 설정하고 큰 데이터와 작은 데이터의 위치를 바꾼다. (분할 / 파티션)
    - 호어 분할 : 리스트에서 첫 번째 데이터를 피벗으로 정한다.
    - 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.
    - 큰 데이터와 작은 데이터 위치를 바꾸며 나아간다.
    - 만약 데이터를 찾는 과정이 중첩된 경우, 작은 데이터와 피벗을 교환한다
    - 결과적으로 피벗을 기준으로 왼쪽에는 피벗보다 작은 데이터, 오른쪽에는 피벗보다 큰 데이터들이 위치하게 된다.
    - 각 위치에 있는 데이터들끼리 다시 위의 과정을 반복한다.
- 시간 복잡도 : $O(NlogN)$
    - 하지만 이미 데이터가 많이 정렬되어 있는 경우 매우 느리게 동작한다
    
# 4. 계수 정렬

- 가장 큰 데이터와 가장 작은 데이터의 차이가 크지 않으며(대략 백만까지) 모두 양의 정수로 이루어져 있는 데이터의 경우에만 이용 가능
    - 성적 처리와 같은 데이터의 경우
- 전체 데이터를 포함할 수 있는 리스트를 만들어서 각 개수를 카운팅한다
    - 데이터가 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2 일 때,
    - 데이터가 0~9까지의 숫자로 구성되어있으므로 [0]*10 리스트를 만든다.
    - 각 숫자가 등장한 횟수를 기록한다
    - 앞에서 부터 등장한 횟수만큼 값을 출력한다
- 시간 복잡도 : $O(N+K)$ **K : 데이터 최대값
- 공간 복잡도 : 0과 999,999 두가지의 데이터만 있는 경우 매우 비효율적일 수 있다.
